<h1 align="center">üöÄ NearX - Stellar Bootcamp</h1>

<h1 align="center">

:pushpin: [Aula 1 - DeFi & Economia Tokenizada: Tokens, Criptomoedas e Web3 Desvendados](https://www.youtube.com/live/ZxGUWEGKgZ8?si=pxw_EkvV__Y0H51Y)

</h1>

## üéØ **Resumo Executivo do Bootcamp**

### ‚úÖ **Status: BOOTCAMP COMPLETO E FUNCIONAL!**

Este bootcamp demonstra a **implementa√ß√£o completa** de smart contracts na Stellar usando Soroban, desde conceitos b√°sicos at√© **testes em produ√ß√£o na testnet**.

### üöÄ **Funcionalidades Implementadas e Testadas:**

#### **Aula 1-2: Fundamentos**
- ‚úÖ **DeFi e Economia Tokenizada** - Conceitos fundamentais
- ‚úÖ **Stellar Stack** - Arquitetura completa da rede
- ‚úÖ **SDKs e Ferramentas** - Python, JavaScript, CLI
- ‚úÖ **Node Local** - Setup completo com monitoramento

#### **Aula 3-4: Smart Contracts**
- ‚úÖ **Rust e Soroban** - Linguagem e plataforma
- ‚úÖ **Contratos B√°sicos** - Flipper, Counter, Task Manager
- ‚úÖ **Storage Patterns** - Instance, Persistent, Temporary
- ‚úÖ **TTL Management** - Gerenciamento de ciclo de vida

#### **Aula 5: Tokens ERC-20**
- ‚úÖ **Contrato Token Completo** - Padr√£o ERC-20 implementado
- ‚úÖ **Testes Locais** - Funcionando perfeitamente
- ‚úÖ **Testes na Testnet** - **CONTRATO 100% FUNCIONAL EM PRODU√á√ÉO**
- ‚úÖ **Scripts Automatizados** - Deploy e testes automatizados

### üìä **Resultados dos Testes:**

**Local:** Contrato funcionando perfeitamente
**Testnet:** Contract ID `CBXWMW3YLXYL7DKOCCMKQ7M7CEGMWXB5TQB2BSF3BNVVQR73DPXDYNPW`

**Saldos Finais na Testnet:**
- Bob: 800 DREX
- Alice: 625 DREX
- Total em Circula√ß√£o: 1425 DREX

### üéâ **Conclus√£o:**
O bootcamp est√° **100% completo** e o contrato token est√° **pronto para uso em produ√ß√£o** na mainnet da Stellar!

---

<p align="left">

### O que √© DeFi? 
<p align="center">
  <img src="./aula01/01.jpg">
</p>

**DeFi**, ou **Decentralized Finance (Finan√ßas Descentralizadas)**, √© um movimento que utiliza tecnologia blockchain para criar servi√ßos financeiros sem a necessidade de intermedi√°rios tradicionais, como bancos ou corretoras.

#### Aqui est√£o alguns pontos-chave sobre o DeFi:

- **Descentraliza√ß√£o:** As transa√ß√µes ocorrem diretamente entre os usu√°rios, sem a necessidade de autoridades centralizadas.

- **Contratos Inteligentes:** Utilizam programas autoexecut√°veis (smart contracts) para automatizar opera√ß√µes financeiras, como empr√©stimos e pagamentos.

- **Transpar√™ncia:** Todas as transa√ß√µes s√£o registradas na blockchain, tornando-as audit√°veis e transparentes.

- **Acessibilidade:** Qualquer pessoa com acesso √† internet pode participar, eliminando processos burocr√°ticos complexos.

- **Interoperabilidade:** Muitos protocolos DeFi s√£o projetados para funcionar de forma integrada com outros servi√ßos dentro do ecossistema blockchain.

<br>

O **DeFi** est√° revolucionando a forma como lidamos com servi√ßos financeiros, oferecendo mais autonomia, efici√™ncia e transpar√™ncia.

Por outro lado, temos o **TradFi**, ou **Traditional Finance (Finan√ßas Tradicionais)**, que opera dentro de um sistema mais estruturado e regulamentado, mas com maior depend√™ncia de intermedi√°rios e processos burocr√°ticos.

#### Comparando TradFi e DeFi

| Aspecto                | TradFi                            | DeFi                               |
|------------------------|-----------------------------------|------------------------------------|
| **Centraliza√ß√£o**      | Institui√ß√µes Financeiras          | Blockchain                         |
| **Intermedia√ß√£o**      | Necess√°rio                        | N√£o necess√°rio                     |
| **Transpar√™ncia**      | Limitada                          | Alta, gra√ßas √† blockchain          |
| **Acesso**             | Restrito                          | Acess√≠vel a qualquer pessoa com internet |
| **Seguran√ßa**          | Regulamentado                     | Contratos inteligentes e blockchain |
| **Efici√™ncia**         | Processos mais lentos e caros     | Automa√ß√£o e efici√™ncia com contratos inteligentes |

<br>

Enquanto o **TradFi** oferece seguran√ßa e regulamenta√ß√£o dentro de um sistema centralizado, o **DeFi** proporciona maior transpar√™ncia, acessibilidade e efici√™ncia atrav√©s da descentraliza√ß√£o e da automa√ß√£o. Ambos t√™m seus m√©ritos e limita√ß√µes, e o futuro pode ver uma integra√ß√£o maior entre essas duas abordagens, trazendo o melhor dos dois mundos para os usu√°rios.

<br>

### O que √© economia tokenizada?
<p align="center">
  <img src="./aula01/02.jpg">
</p>

A **economia tokenizada** √© um conceito inovador que est√° ganhando destaque, especialmente com o avan√ßo das tecnologias de blockchain e criptografia. Em ess√™ncia, trata-se da cria√ß√£o de tokens digitais que representam ativos do mundo real ou virtuais. Esses tokens podem ser utilizados para uma variedade de finalidades, como transa√ß√µes, investimentos e at√© programas de fidelidade.

<br>

A economia tokenizada e o dinheiro program√°vel s√£o conceitos complementares que est√£o impulsionando a transforma√ß√£o digital do setor financeiro.

#### Economia Tokenizada:

- **Tokens Digitais:** Representam ativos do mundo real ou virtuais, facilitando a negocia√ß√£o e a transa√ß√£o desses ativos na blockchain.

- **Blockchain:** Tecnologia que sustenta a economia tokenizada, garantindo seguran√ßa e transpar√™ncia nas transa√ß√µes.

- **Transpar√™ncia e Seguran√ßa:** Transa√ß√µes registradas na blockchain s√£o dif√≠ceis de adulterar, promovendo confian√ßa.

- **Descentraliza√ß√£o:** Elimina a necessidade de intermedi√°rios, como bancos e corretores.

- **Acessibilidade:** Democratiza o acesso a investimentos e transa√ß√µes, tornando-os mais acess√≠veis a um p√∫blico mais amplo.

#### Dinheiro Program√°vel:

- **Contratos Inteligentes:** Contratos autoexecut√°veis com termos escritos em c√≥digo, garantindo que condi√ß√µes espec√≠ficas sejam cumpridas antes da libera√ß√£o dos fundos.

- **Autonomia e Efici√™ncia:** Reduz a necessidade de intermedi√°rios, diminuindo custos e aumentando a efici√™ncia.

- **Personaliza√ß√£o:** Permite solu√ß√µes financeiras personalizadas, como pagamentos autom√°ticos e gest√£o de doa√ß√µes.

- **Seguran√ßa:** Garantida pela tecnologia blockchain, dif√≠cil de ser adulterada.

- **Transpar√™ncia:** Regras e transa√ß√µes s√£o transparentes e imut√°veis, promovendo maior confian√ßa entre as partes.

Ambos os conceitos s√£o partes essenciais da nova era das finan√ßas digitais, oferecendo mais flexibilidade, seguran√ßa e efici√™ncia.

<br>

### Tokenecomics Stellar, principais DeFi.
<p align="center">
  <img src="./aula01/03.jpg">
</p>

#### Tokenomics do Stellar (XLM)

- **Nome:** Stellar Lumens (XLM)

- **Fundo de Desenvolvimento:** A Stellar Development Foundation (SDF) √© respons√°vel pelo desenvolvimento e promo√ß√£o da rede Stellar.

- **Oferta Total:** 50 bilh√µes de XLM.

- **Oferta Circulante:** 28,9 bilh√µes de XLM.

- **Uso:** XLM √© usado para pagar taxas de transa√ß√£o na rede Stellar e como uma ponte para facilitar transa√ß√µes internacionais.

- **Consensus Protocol:** Stellar usa o Stellar Consensus Protocol (SCP), que √© um mecanismo de consenso federado que n√£o depende de minera√ß√£o.

- **Velocidade:** A rede Stellar pode processar at√© 1.000 transa√ß√µes por segundo.

- **Interoperabilidade:** Permite a cria√ß√£o e troca de ativos digitais, facilitando a integra√ß√£o com o sistema financeiro tradicional.

#### Principais Protocolos DeFi

- **Aave (AAVE):** Plataforma descentralizada para empr√©stimos e empr√©stimos flash.

- **Maker (MKR):** Criador do stablecoin DAI e plataforma para empr√©stimos descentralizados.

- **Uniswap (UNI):** Exchange descentralizada de criptomoedas que permite a negocia√ß√£o sem intermedi√°rios.

- **Chainlink (LINK):** Fornece dados externos para contratos inteligentes, essencial para muitas aplica√ß√µes DeFi.

- **PancakeSwap (CAKE):** Exchange descentralizada na Binance Smart Chain, conhecida por suas taxas baixas.

- **Avalanche (AVAX):** Plataforma de contratos inteligentes r√°pida e escal√°vel.

- **Ethereum (ETH):** A maior plataforma DeFi, onde muitos projetos DeFi s√£o constru√≠dos.

- **Fantom (FTM):** Rede de blockchain projetada para alta escalabilidade e baixo custo.

- **Lido DAO (LDO):** Plataforma para staking de ativos em v√°rias redes blockchain.

- **Jupiter (JUP):** Protocolo DeFi que facilita a interoperabilidade entre diferentes blockchains.

Esses protocolos s√£o alguns dos principais exemplos de como o DeFi est√° transformando o setor financeiro, oferecendo solu√ß√µes descentralizadas, transparentes e acess√≠veis.

<br>

### O que s√£o Tokens, Assets e Criptomoedas?
<p align="center">
  <img src="./aula01/04.jpg">
</p>

A imagem oferece uma vis√£o clara e relevante sobre os diferentes componentes e camadas do ecossistema de blockchain e criptomoedas, destacando suas intera√ß√µes e integra√ß√µes. Ela ilustra um diagrama com v√°rias camadas que fazem parte deste ecossistema, incluindo tokens, ativos, NFTs e criptomoedas. Aqui est√° um resumo das camadas apresentadas:

- **Camada de Agrega√ß√£o (Aggregation layer):** Inclui Agregador 1, Agregador 2 e Agregador 3.
  - Esta camada agrupa e consolida dados de v√°rias fontes diferentes, fornecendo uma vis√£o abrangente dos ativos dispon√≠veis, taxas de c√¢mbio, oportunidades de empr√©stimo, etc. Esses agregadores facilitam a busca e compara√ß√£o de informa√ß√µes para os usu√°rios.

- **Camada de Aplica√ß√£o (Application layer):** Inclui v√°rias aplica√ß√µes, como troca, empr√©stimo, derivativos, gest√£o de ativos, entre outras.
  - Esta camada √© onde os usu√°rios interagem diretamente com diferentes servi√ßos financeiros. Aplica√ß√µes de troca permitem a compra e venda de criptomoedas, aplica√ß√µes de empr√©stimo permitem que usu√°rios emprestem e tomem emprestado criptomoedas, e as aplica√ß√µes de derivativos permitem a negocia√ß√£o de contratos baseados em criptomoedas. A gest√£o de ativos inclui ferramentas e servi√ßos para ajudar os usu√°rios a gerenciar seus investimentos.

- **Camada de Protocolo (Protocol layer):** Inclui protocolos para troca, empr√©stimo, derivativos e gest√£o de ativos.
  - Estes s√£o os "regramentos" ou "contratos" que governam as opera√ß√µes das aplica√ß√µes. Eles definem como as transa√ß√µes s√£o realizadas, verificadas e registradas. Cada tipo de aplica√ß√£o (troca, empr√©stimo, etc.) tem protocolos espec√≠ficos que asseguram sua funcionalidade e seguran√ßa.

- **Camada de Ativos (Asset layer):** Inclui ativos nativos do protocolo (ETH), tokens fung√≠veis (ERC-20) e tokens n√£o fung√≠veis (ERC-721).
  - Esta camada inclui todos os tipos de ativos digitais. O ETH (Ethereum) √© o ativo nativo da blockchain Ethereum. Tokens fung√≠veis (ERC-20) s√£o tokens que t√™m o mesmo valor e s√£o intercambi√°veis (como moedas). Tokens n√£o fung√≠veis (ERC-721) s√£o √∫nicos e n√£o intercambi√°veis, frequentemente usados para representar itens digitais colecion√°veis ou arte digital (NFTs).

- **Camada de Liquida√ß√£o (Settlement layer):** Inclui a blockchain Ethereum.
  - Esta √© a camada onde as transa√ß√µes s√£o finalizadas e registradas de forma permanente. A blockchain Ethereum √© um ledger distribu√≠do que assegura que todas as transa√ß√µes s√£o transparentes, imut√°veis e verific√°veis por qualquer pessoa.

- **Camada 0 (Layer 0):** Inclui ferramentas de desenvolvimento e linguagens como Cosmos SDK, Polkadot SDK, Rust, Java, Golang e C/C++.
  - Esta camada inclui as ferramentas e tecnologias b√°sicas usadas para criar e desenvolver todas as outras camadas e aplica√ß√µes. As ferramentas de desenvolvimento ajudam os programadores a criar blockchains e dApps (aplica√ß√µes descentralizadas) de forma mais eficiente. As linguagens de programa√ß√£o s√£o usadas para escrever o c√≥digo que alimenta esses sistemas.

Cada camada desempenha um papel essencial no funcionamento geral do ecossistema de criptomoedas e blockchain, desde a base tecnol√≥gica at√© a intera√ß√£o direta do usu√°rio.

<br>

### Como funciona a web3?
<p align="center">
  <img src="./aula01/05.jpg">
</p>

A Web3 representa uma nova era da internet, onde a descentraliza√ß√£o √© a chave. Em vez de depender de intermedi√°rios centralizados, os aplicativos e servi√ßos na Web3 utilizam a tecnologia blockchain para operar de forma independente e segura.

#### Vamos desvendar os principais elementos:

- **Desenvolvedor (DEV):** O processo come√ßa com o desenvolvedor que cria o c√≥digo e os aplicativos.

- **Contrato Inteligente (SMARTCONTRACT):** O desenvolvedor programa contratos inteligentes, que s√£o essencialmente contratos autoexecut√°veis com os termos do acordo diretamente escritos no c√≥digo.

- **Backend e Frontend:** Os contratos inteligentes se conectam tanto ao backend (parte do aplicativo que gerencia a l√≥gica e a base de dados) quanto ao frontend (a interface do usu√°rio).

- **Carteira (WALLET):** A interface do usu√°rio se conecta a uma carteira digital, que √© usada para gerenciar as criptomoedas e outras chaves digitais.

- **Usu√°rio (USER):** O usu√°rio interage com o frontend do aplicativo e usa a carteira para realizar transa√ß√µes.

<br>

### Como a Stellar se encaixa no mundo web3?

A **Stellar** √© uma plataforma blockchain projetada para facilitar transa√ß√µes financeiras r√°pidas e acess√≠veis em todo o mundo. Ela se encaixa na Web3 ao permitir a cria√ß√£o e troca de ativos digitais (tokens) de maneira descentralizada e segura. Aqui est√£o alguns pontos-chave sobre como a Stellar se integra √† Web3:

 - **Tokeniza√ß√£o de Ativos:** A Stellar permite a cria√ß√£o de tokens representando ativos financeiros ou outros tipos de valor, facilitando a troca e a liquidez.

- **Transa√ß√µes R√°pidas e Econ√¥micas:** A Stellar oferece taxas de transa√ß√£o muito baixas e tempos de processamento r√°pidos, o que √© crucial para aplica√ß√µes financeiras em tempo real.

- **Interoperabilidade:** A Stellar se conecta a v√°rias moedas fiduci√°rias e outras plataformas blockchain, permitindo a transfer√™ncia de valor entre diferentes sistemas.

- **Desenvolvimento de Aplica√ß√µes:** A Stellar fornece ferramentas e SDKs (kits de desenvolvimento de software) que facilitam a cria√ß√£o de aplicativos descentralizados (dApps) e contratos inteligentes.

- **Foco em Inclus√£o Financeira:** A Stellar tem como objetivo tornar os servi√ßos financeiros mais acess√≠veis a pessoas em todo o mundo, especialmente em regi√µes onde o acesso a servi√ßos banc√°rios tradicionais √© limitado.

Em resumo, a **Stellar** √© uma plataforma blockchain que se alinha bem com os princ√≠pios da Web3, promovendo a descentraliza√ß√£o, a interoperabilidade e a inclus√£o financeira. 

<br>

### Blockchain low-level: wallet
<p align="center">
  <img src="./aula01/06.jpg">
</p>

**Blockchain low-level wallet** √© um termo t√©cnico que se refere a um tipo de carteira de criptomoedas que opera diretamente na camada mais baixa da infraestrutura blockchain. Em outras palavras, √© uma carteira que interage diretamente com a blockchain sem a necessidade de intermedi√°rios ou servi√ßos adicionais.

Essa imagem √© relevante pois explica o processo de gera√ß√£o de chaves criptogr√°ficas para carteiras blockchain, crucial para garantir transa√ß√µes seguras na tecnologia blockchain.

#### Aqui est√£o os elementos principais e seu significado:

- **Chave P√∫blica:** GBTIDN5UQ3P4HT3CSIEYU5SF6INX0MYOTU6U5KM67QMXPPUCTABT35U5

  - Utilizada para receber transa√ß√µes na rede blockchain.

- **Chave Privada:** SAKKTW5AEJ07Y5DOGUKINE6NFS5CR370WK3WIX4JWQ7LHOOUIH2VQYR4

  - Mantida em segredo e usada para assinar transa√ß√µes, provando a propriedade dos fundos.

- **Algoritmos Utilizados:**

  - O Stellar usa uma combina√ß√£o dos algoritmos SHA-256 e RIPEMD-160 para aumentar a seguran√ßa: RIPEMD160(SHA256(data)).

- **Passos para a Gera√ß√£o de Chaves:**

  - Um seed aleat√≥rio de 256 bits √© gerado.

  - Esse seed √© hashado usando a fun√ß√£o hash SHA-512, produzindo um digest de 512 bits.

  - Os primeiros 256 bits do digest se tornam a chave privada.

  - A chave p√∫blica √© derivada da chave privada usando o algoritmo ed25519.

#### Aqui est√£o alguns pontos chave sobre essas carteiras:

- **Chave Privada e P√∫blica:** Cada carteira possui uma chave privada e uma chave p√∫blica. A chave privada √© um segredo que voc√™ deve manter seguro, enquanto a chave p√∫blica √© usada para receber transa√ß√µes.

- **Transa√ß√µes Diretas:** As carteiras low-level permitem que voc√™ envie e receba transa√ß√µes diretamente na blockchain. Isso significa que voc√™ tem controle total sobre suas transa√ß√µes sem depender de terceiros.

- **Seguran√ßa:** Como voc√™ mant√©m controle direto sobre suas chaves, a seguran√ßa das suas transa√ß√µes e fundos depende de como voc√™ protege suas chaves privadas.

- **Software e Hardware:** Existem dois tipos principais de carteiras low-level: software wallets (aplicativos que voc√™ instala no seu dispositivo) e hardware wallets (dispositivos f√≠sicos projetados para armazenar chaves de forma segura).

<br>

### Blockchain low-level: Tx
<p align="center">
  <img src="./aula01/07.jpg">
</p>

A imagem ilustra o processo onde uma chave privada e uma transa√ß√£o s√£o combinadas para criar uma assinatura. Essa assinatura, junto com a chave p√∫blica, resulta em uma transa√ß√£o assinada. Esse processo √© fundamental na tecnologia blockchain para garantir a autenticidade e a integridade das transa√ß√µes.

<br>


### Blockchain low-level: Blocks
<p align="center">
  <img src="./aula01/08.jpg">
</p>

Essa imagem ajuda a ilustrar como os blocos na blockchain s√£o compostos por conjuntos de transa√ß√µes e como eles se conectam formando uma cadeia cont√≠nua. A blockchain √© como um livro-raz√£o digital descentralizado que registra todas as transa√ß√µes de forma segura e imut√°vel. Cada bloco cont√©m um conjunto de transa√ß√µes, e todos os blocos est√£o interligados, formando uma cadeia (da√≠ o nome "blockchain").

#### Aqui est√£o os principais componentes de um bloco em n√≠vel baixo:

- **Cabe√ßalho do Bloco:** Cont√©m metadados sobre o bloco, como a vers√£o, o hash do bloco anterior, o hash do Merkle root (que √© uma √°rvore hash que resume todas as transa√ß√µes no bloco), um timestamp, a dificuldade de minera√ß√£o, e o nonce (um n√∫mero usado uma √∫nica vez).

- **Transa√ß√µes:** O bloco cont√©m uma lista de transa√ß√µes. Cada transa√ß√£o representa uma mudan√ßa no estado do blockchain, como a transfer√™ncia de criptomoedas de uma carteira para outra.

- **Hash do Bloco Anterior:** Cada bloco cont√©m um hash criptogr√°fico do bloco anterior. Isso cria uma cadeia de blocos (da√≠ o nome blockchain), onde cada bloco est√° matematicamente vinculado ao anterior, garantindo a integridade da cadeia.

- **Nonce:** Um valor num√©rico que √© ajustado durante o processo de minera√ß√£o para encontrar um hash que atenda a certos requisitos de dificuldade.

Esses componentes garantem que o blockchain seja seguro, imut√°vel e transparente. Cada bloco √© vinculado ao anterior, formando uma cadeia cont√≠nua e linear que √© resistente a modifica√ß√µes e fraudes.

<br>

### Blockchain low-level: Consenso
<p align="center">
  <img src="./aula01/09.jpg">
</p>

Consenso de n√≠vel baixo (Low Level Consensus) em blockchain refere-se aos mecanismos fundamentais utilizados para alcan√ßar um acordo entre todos os participantes da rede sobre o estado do blockchain. Em outras palavras, √© o processo pelo qual todas as partes da rede concordam em um conjunto de dados ou transa√ß√µes para garantir a integridade e a seguran√ßa do sistema.

#### Aqui est√£o os principais mecanismos de consenso:

- **Proof of Work (PoW):**

  - Os mineradores competem para resolver problemas matem√°ticos complexos.

  - O primeiro a resolver adiciona um novo bloco √† cadeia e recebe uma recompensa.

  - Este m√©todo √© seguro, mas consome muita energia.

- **Proof of Stake (PoS):**

  - Em vez de mineradores, existem validadores que s√£o escolhidos com base na quantidade de criptomoeda que possuem e est√£o dispostos a "apostar" como garantia.

  - Reduz o consumo de energia comparado ao PoW.

  - A seguran√ßa √© baseada na quantidade de valor apostado.

- **Stellar Consensus Protocol (SCP):**

  - Utiliza o protocolo [Federated Byzantine Agreement (FBA)](./docs/protocol-fba.md).

  - Os n√≥s se dividem em pequenos grupos chamados de quorum slices.

  - Alcan√ßa consenso r√°pido com menos consumo de energia.

O consenso √© essencial para o funcionamento das blockchains, garantindo que todos os participantes tenham uma vis√£o uniforme do ledger e que transa√ß√µes fraudulentas sejam evitadas.

<br>

### Blockchain low-level: SmartContracts
<p align="center">
  <img src="./aula01/10.jpg">
</p>

Contratos inteligentes s√£o programas de computador que s√£o executados em uma blockchain. Eles s√£o definidos por c√≥digos e regras pr√©-estabelecidas que s√£o automaticamente executadas quando determinadas condi√ß√µes s√£o atendidas. 

#### Aqui est√£o alguns pontos importantes:

- **Autonomia:** Os contratos inteligentes operam de forma autom√°tica sem a necessidade de intermedi√°rios.

- **Imutabilidade:** Uma vez implantados na blockchain, os contratos inteligentes n√£o podem ser alterados.

- **Transpar√™ncia:** Todas as transa√ß√µes e opera√ß√µes executadas pelos contratos inteligentes s√£o vis√≠veis na blockchain.

#### Blockchain Low-Level

No n√≠vel mais baixo, a blockchain e os contratos inteligentes envolvem v√°rias camadas t√©cnicas e componentes:

 - **Linguagem de Programa√ß√£o:** Contratos inteligentes s√£o geralmente escritos em linguagens espec√≠ficas como Solidity para Ethereum, ou Rust e AssemblyScript para outras plataformas de blockchain como Polkadot.

- **Compila√ß√£o:** O c√≥digo do contrato inteligente √© compilado em bytecode, que pode ser entendido e executado pela m√°quina virtual da blockchain (como a Ethereum Virtual Machine, EVM).

- **M√°quina Virtual (VM):** A VM √© um ambiente de execu√ß√£o isolado que garante que o c√≥digo seja executado de forma segura e consistente em todos os n√≥s da rede.

- **Transa√ß√µes e Eventos:** Os contratos inteligentes podem enviar e receber transa√ß√µes, emitir eventos que outros contratos ou usu√°rios podem ouvir e responder.

- **Persist√™ncia:** O estado dos contratos inteligentes (como saldos de contas e outros dados) √© armazenado na blockchain e pode ser acessado e modificado pelas fun√ß√µes do contrato.

#### Exemplo Pr√°tico

Este √© um exemplo de um contrato inteligente simples escrito em Solidity. Ele permite armazenar e recuperar um valor na blockchain.

##### Contrato Solidity

```solidity 
pragma solidity ^0.8.0;

contract SimpleStorage {
    uint256 public data;

    function setData(uint256 _data) public {
        data = _data;
    }

    function getData() public view returns (uint256) {
        return data;
    }
}
```
#### Descri√ß√£o

- setData: Esta fun√ß√£o permite definir o valor da vari√°vel data.

- getData: Esta fun√ß√£o retorna o valor atual armazenado na vari√°vel data.

#### Como Usar

- **Implante o Contrato:** Implante o contrato na blockchain usando uma ferramenta como Remix, Truffle, ou Hardhat.

- **Interaja com o Contrato:**

  - Use a fun√ß√£o setData para armazenar um valor.

  - Use a fun√ß√£o getData para recuperar o valor armazenado.

- **Requisitos**
  - Solidity ^0.8.0

</p>


<br>

## Aula 2

### 0. Blockchain paths

O universo blockchain oferece diferentes caminhos de carreira, cada um com seu foco, tecnologias e desafios. Veja os principais:

- **Core Blockchain Engineer** (Node)
  - Foco: redes, criptografia, protocolo de consenso, DevOps
  - N√≠vel: Avan√ßado
  - Desafio: Exige conhecimento profundo em sistemas distribu√≠dos, seguran√ßa e infraestrutura.

- **SDK Engineer** (SDK)
  - Foco: desenvolvimento de SDKs em linguagens como Python, JavaScript, Rust, Ruby, Golang
  - N√≠vel: Intermedi√°rio a Avan√ßado
  - Desafio: Precisa entender tanto o funcionamento da blockchain quanto boas pr√°ticas de desenvolvimento de software.

- **Smart Contract Engineer** (Smartcontract)
  - Foco: desenvolvimento de contratos inteligentes
    - EVM: Solidity, Vyper
    - No-EVM: Rust, Golang
  - N√≠vel: Intermedi√°rio a Avan√ßado
  - Desafio: Requer dom√≠nio de linguagens espec√≠ficas e aten√ß√£o redobrada √† seguran√ßa dos contratos.

- **Integration/Web3 Engineer** (Application)
  - Foco: integra√ß√£o de aplica√ß√µes web3 usando bibliotecas e SDKs (web3js, ethers.js, viem, cardano SDK, etc.)
  - N√≠vel: Intermedi√°rio
  - Desafio: Precisa conectar frontends, carteiras e contratos inteligentes, garantindo boa experi√™ncia do usu√°rio.

> **Observa√ß√£o:** Cada trilha tem n√≠veis de complexidade e desafios pr√≥prios. O ideal √© come√ßar pelo b√°sico e ir avan√ßando conforme o interesse e necessidade do projeto ou carreira.

---

### 1. Consenso da Stellar

O protocolo de consenso da Stellar, chamado **Stellar Consensus Protocol (SCP)**, √© um mecanismo federado que permite que a rede alcance consenso de forma r√°pida, segura e sem a necessidade de minera√ß√£o. Esse tema √© especialmente relevante para quem deseja atuar como **Core Blockchain Engineer**, pois envolve conceitos avan√ßados de redes distribu√≠das, seguran√ßa e toler√¢ncia a falhas.

- O SCP permite que m√∫ltiplas entidades (n√≥s) concordem sobre o estado da rede, mesmo em ambientes abertos e sem confian√ßa pr√©via.
- Diferente de blockchains baseadas em Proof of Work (PoW), o SCP √© eficiente energeticamente e proporciona confirma√ß√µes r√°pidas.
- Para desenvolvedores de aplica√ß√µes e contratos, √© importante entender o b√°sico do consenso, mas o aprofundamento √© mais relevante para quem deseja contribuir com o n√∫cleo do protocolo.
- [Documenta√ß√£o oficial do Stellar Consensus Protocol (SCP)](https://stellar.org/developers-blog/stellar-consensus-protocol)

---

### 2. Stellar Stack

A **Stellar Stack** √© composta por diferentes camadas, cada uma respons√°vel por uma parte fundamental do ecossistema. Entender essa arquitetura ajuda a visualizar onde cada perfil profissional pode atuar:

<p align="center">
  <img src="aula02/assets/stellar-stack.png" alt="Stellar Stack" width="600"/>
</p>

- **Network (Core Protocol):** Camada base, respons√°vel pelo funcionamento do protocolo central da Stellar.
- **Data Availability:** Servi√ßos que garantem o acesso e indexa√ß√£o dos dados da rede (RPC, Horizon, Indexers, Hubble).
- **Developer Tooling:** Ferramentas para desenvolvedores, como SDKs, CLI e Laboratory.
- **Application:** Aplica√ß√µes finais, como carteiras, seletores de carteira, plataformas de ancoragem e SDP.

[Documenta√ß√£o oficial da Stellar Stack](https://developers.stellar.org/docs/learn/architecture/)

Cada camada oferece oportunidades para diferentes perfis de desenvolvedores, desde quem trabalha no n√∫cleo do protocolo at√© quem cria aplica√ß√µes para o usu√°rio final.

#### Explicando cada √°rea da Stellar Stack

- **Network (Core Protocol):**
  - √â o n√∫cleo da rede Stellar, respons√°vel por validar transa√ß√µes, manter o consenso e garantir a seguran√ßa e integridade do ledger. Aqui est√° o c√≥digo-fonte do protocolo, rodando em cada n√≥ da rede, e √© onde ocorrem as decis√µes fundamentais sobre o estado global da blockchain.

- **Data Availability:**
  - Camada que garante o acesso, consulta e indexa√ß√£o dos dados da rede. Inclui:
    - **RPC:** Interfaces para comunica√ß√£o remota com a rede.
    - **Horizon:** API REST que permite que aplica√ß√µes e usu√°rios interajam facilmente com a blockchain Stellar, consultando contas, transa√ß√µes, opera√ß√µes e mais.
    - **Indexers:** Servi√ßos que organizam e facilitam buscas r√°pidas por dados espec√≠ficos na blockchain.
    - **Hubble:** Ferramenta de indexa√ß√£o e an√°lise de dados da rede.

- **Developer Tooling:**
  - Ferramentas que facilitam o desenvolvimento de aplica√ß√µes e integra√ß√µes com a Stellar:
    - **SDKs:** Bibliotecas em v√°rias linguagens (Python, JavaScript, Go, etc.) para interagir com a rede Stellar de forma program√°tica.
    - **CLI:** Interfaces de linha de comando para executar opera√ß√µes, testar e interagir com a rede.
    - **Laboratory:** Ferramenta web para criar, simular e testar transa√ß√µes Stellar de forma visual e interativa.

- **Application:**
  - Camada voltada para o usu√°rio final, onde est√£o as aplica√ß√µes constru√≠das sobre a rede Stellar:
    - **Wallets:** Carteiras digitais para armazenar, enviar e receber ativos Stellar.
    - **Wallet Selector:** Ferramenta para escolher e conectar diferentes carteiras em aplica√ß√µes.
    - **Anchor Platform:** Solu√ß√µes para integra√ß√£o de institui√ß√µes financeiras (anchors) com a rede Stellar, facilitando dep√≥sitos e saques de moedas fiduci√°rias.
    - **SDP (Stellar Disbursement Platform):** Plataforma para distribui√ß√£o de pagamentos em massa usando Stellar.

- Fundamentos sobre Stellar.
- Configurando FullNode e DevOps.
- Interagindo com o FullNode usando SDK.

### 3. SDKs da Stellar

Os **SDKs (Software Development Kits)** da Stellar s√£o bibliotecas que facilitam a integra√ß√£o de aplica√ß√µes com a rede Stellar, permitindo criar contas, enviar transa√ß√µes, consultar dados e muito mais de forma program√°tica.

#### Onde encontrar os SDKs oficiais?

A lista completa e atualizada dos SDKs oficiais e mantidos pela comunidade pode ser encontrada na documenta√ß√£o oficial da Stellar:

- [SDKs na documenta√ß√£o oficial da Stellar](https://developers.stellar.org/docs/software-and-sdks/)

#### Linguagens dispon√≠veis

A Stellar oferece SDKs oficiais e de comunidade para diversas linguagens, incluindo:

- **JavaScript/TypeScript** ‚Äì Ideal para aplica√ß√µes web e Node.js.
- **Python** ‚Äì Muito usado para scripts, automa√ß√µes e backend.
- **Go** ‚Äì √ìtimo para aplica√ß√µes de alta performance e servi√ßos backend.
- **Java** ‚Äì Usado em aplica√ß√µes corporativas e Android.
- **C#** ‚Äì Para aplica√ß√µes .NET.
- **Ruby** ‚Äì Para desenvolvedores Ruby on Rails.
- **Scala, PHP, Dart, Rust, Swift** ‚Äì Outras op√ß√µes mantidas pela comunidade.

#### Incentivo √† cria√ß√£o de novos SDKs

A Stellar incentiva ativamente a comunidade a criar e manter SDKs em novas linguagens, ampliando o ecossistema e facilitando o acesso de desenvolvedores de diferentes backgrounds. Se voc√™ domina uma linguagem que ainda n√£o possui um SDK maduro, pode contribuir criando um novo SDK ou ajudando a evoluir os existentes.

> **Dica:** Sempre confira a documenta√ß√£o oficial para ver exemplos, tutoriais e o status de cada SDK.

### 4. Lista de Opera√ß√µes da Stellar

A Stellar oferece uma variedade de opera√ß√µes que podem ser executadas em transa√ß√µes na rede. Cada opera√ß√£o representa uma a√ß√£o espec√≠fica, como criar uma conta, realizar um pagamento, gerenciar ofertas, criar ou gerenciar ativos, entre outras.

#### Principais opera√ß√µes dispon√≠veis:

- **Create Account:** Cria uma nova conta na rede Stellar.
- **Payment:** Envia ativos (XLM ou tokens) de uma conta para outra.
- **Path Payment:** Realiza pagamentos que podem envolver convers√£o autom√°tica de ativos ao longo de um caminho.
- **Manage Offer:** Cria, atualiza ou remove ofertas de compra/venda de ativos no livro de ordens.
- **Create Passive Offer:** Cria uma oferta passiva que n√£o consome ofertas existentes.
- **Set Options:** Altera configura√ß√µes da conta, como chaves de assinatura e limites.
- **Change Trust:** Adiciona ou remove confian√ßa em um ativo/token.
- **Allow Trust:** Permite que outra conta confie em um ativo emitido.
- **Account Merge:** Mescla o saldo de uma conta em outra e remove a conta original.
- **Inflation:** (Obsoleta) Participava do mecanismo de infla√ß√£o da rede.
- **Manage Data:** Armazena ou remove dados arbitr√°rios associados a uma conta.
- **Bump Sequence:** Avan√ßa o n√∫mero de sequ√™ncia da conta para evitar repeti√ß√µes de transa√ß√µes.

#### Onde consultar a lista completa?

A lista oficial e detalhada de todas as opera√ß√µes suportadas pela Stellar, incluindo exemplos de uso e par√¢metros, est√° dispon√≠vel na documenta√ß√£o:

- [Stellar Operations - Official Documentation](https://developers.stellar.org/docs/learn/concepts/list-of-operations/)

> **Dica:** Entender as opera√ß√µes √© fundamental para criar aplica√ß√µes completas e explorar todo o potencial da rede Stellar.

### 5. Estruturas de Dados da Stellar

A Stellar utiliza diversas estruturas de dados para organizar, registrar e validar todas as informa√ß√µes e transa√ß√µes que ocorrem na rede. Entender essas estruturas √© essencial para compreender como a blockchain da Stellar funciona ‚Äúpor baixo dos panos‚Äù.

#### Principais estruturas de dados:

- **Ledger (Livro-raz√£o):**
  - O ledger √© o registro global e imut√°vel de todas as transa√ß√µes e estados das contas na rede Stellar.
  - Cada ledger √© como um ‚Äúbloco‚Äù que cont√©m um snapshot do estado da rede em um determinado momento.
  - Os ledgers s√£o numerados sequencialmente e cada um referencia o anterior, formando uma cadeia (blockchain).
  - Um ledger inclui: transa√ß√µes validadas, resultados das opera√ß√µes, informa√ß√µes de contas, ofertas, trustlines, dados e muito mais.

- **Transaction (Transa√ß√£o):**
  - Uma transa√ß√£o √© um conjunto de opera√ß√µes agrupadas e enviadas para serem processadas em um ledger.
  - Cada transa√ß√£o possui um remetente, uma assinatura, um n√∫mero de sequ√™ncia e pode conter m√∫ltiplas opera√ß√µes.

- **Operation (Opera√ß√£o):**
  - Cada opera√ß√£o √© uma a√ß√£o individual dentro de uma transa√ß√£o (ex: pagamento, cria√ß√£o de conta, altera√ß√£o de trustline, etc).
  - Uma transa√ß√£o pode conter v√°rias opera√ß√µes.

- **Account (Conta):**
  - Representa um usu√°rio ou entidade na rede Stellar.
  - Cada conta possui um endere√ßo p√∫blico, saldo, n√∫mero de sequ√™ncia, configura√ß√µes de seguran√ßa, trustlines e dados associados.

- **Trustline:**
  - Uma trustline √© uma rela√ß√£o de confian√ßa entre uma conta e um ativo/token, permitindo que a conta mantenha e transacione aquele ativo.

- **Offer (Oferta):**
  - Ofertas s√£o ordens de compra ou venda de ativos no livro de ordens descentralizado da Stellar.

- **Data Entry:**
  - Permite que contas armazenem pequenos peda√ßos de dados arbitr√°rios na rede.

#### Onde aprender mais?

A documenta√ß√£o oficial da Stellar traz detalhes t√©cnicos e exemplos de cada estrutura:

- [Stellar Data Structures - Official Documentation](https://developers.stellar.org/docs/learn/concepts/data-structures/)

> **Dica:** Compreender as estruturas de dados √© fundamental para quem deseja criar integra√ß√µes avan√ßadas, explorar dados hist√≥ricos ou contribuir para o desenvolvimento do protocolo.

### 6. SEPs (Stellar Ecosystem Proposals)

Os **SEPs (Stellar Ecosystem Proposals)** s√£o propostas de padroniza√ß√£o criadas pela comunidade e pela equipe da Stellar para definir regras, formatos e melhores pr√°ticas para o desenvolvimento de aplica√ß√µes, integra√ß√µes e servi√ßos no ecossistema Stellar.

#### O que s√£o SEPs?

- SEPs funcionam como ‚Äúnormas t√©cnicas‚Äù que ajudam a garantir a interoperabilidade entre diferentes aplica√ß√µes, carteiras, exchanges, anchors e outros servi√ßos que utilizam a rede Stellar.
- Eles abordam desde formatos de arquivos, fluxos de autentica√ß√£o, APIs, at√© padr√µes para emiss√£o de ativos, integra√ß√£o de anchors, KYC, pagamentos, entre outros.

#### Exemplos de SEPs importantes

- **SEP-1:** Padr√£o para documenta√ß√£o de ativos.
- **SEP-6:** Protocolo de dep√≥sitos e saques fiat via anchors.
- **SEP-10:** Autentica√ß√£o de usu√°rios via challenge transaction.
- **SEP-12:** Padr√£o para coleta de informa√ß√µes KYC.
- **SEP-24:** Protocolo de dep√≥sitos e saques interativos.
- **SEP-31:** Pagamentos cross-border entre institui√ß√µes.
- **SEP-38:** Cota√ß√µes de pre√ßos para convers√£o de ativos.

#### Onde encontrar e como usar

- A lista completa de SEPs, com explica√ß√µes, status e exemplos de implementa√ß√£o, est√° dispon√≠vel no reposit√≥rio oficial:
  - [Stellar Ecosystem Proposals (SEPs) - Lista oficial](https://github.com/stellar/stellar-protocol/tree/master/ecosystem)
- Antes de criar uma nova integra√ß√£o ou servi√ßo, √© recomend√°vel consultar os SEPs relevantes para garantir compatibilidade e seguir as melhores pr√°ticas do ecossistema.

> **Dica:** SEPs s√£o vivos! Eles evoluem conforme a comunidade prop√µe melhorias e novas necessidades surgem.

### 7. Usando o SDK da Stellar em Python

O **Stellar Python SDK** √© uma biblioteca oficial que permite interagir com a rede Stellar de forma simples e eficiente, facilitando a cria√ß√£o de contas, envio de pagamentos, emiss√£o de tokens, consulta de dados e muito mais.

#### Instala√ß√£o

Voc√™ pode instalar o SDK oficial com poetry:

```bash
poetry install
```

Ou se preferir usar pip diretamente:

```bash
pip install stellar-sdk
```

#### Principais recursos

- **Cria√ß√£o de contas:** Gere chaves, crie contas e configure trustlines.
- **Pagamentos:** Envie XLM ou tokens entre contas.
- **Emiss√£o de tokens:** Crie ativos personalizados e distribua para outras contas.
- **Consulta de dados:** Busque informa√ß√µes sobre contas, transa√ß√µes, opera√ß√µes e ledgers.
- **Assinatura e envio de transa√ß√µes:** Monte, assine e envie transa√ß√µes para a rede Stellar.

#### Exemplo b√°sico: criando uma conta e enviando um pagamento

```python
from stellar_sdk import Keypair, Server, TransactionBuilder, Network

# Gerar um par de chaves
keypair = Keypair.random()
public_key = keypair.public_key
secret = keypair.secret

# Conectar ao servidor Horizon (testnet)
server = Server("https://horizon-testnet.stellar.org")

# Buscar conta existente (exemplo)
source_account = server.load_account(public_key="SUA_PUBLIC_KEY")

# Criar transa√ß√£o de pagamento
transaction = (
    TransactionBuilder(
        source_account=source_account,
        network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
        base_fee=100,
    )
    .append_payment_op(destination="DESTINO_PUBLIC_KEY", amount="10", asset_code="XLM")
    .build()
)

# Assinar e enviar
transaction.sign("SUA_SECRET_KEY")
response = server.submit_transaction(transaction)
print(response)
```

#### Documenta√ß√£o oficial

- [Stellar Python SDK - Documenta√ß√£o](https://stellar-sdk.readthedocs.io/en/latest/)
- [Exemplos de uso na documenta√ß√£o oficial](https://developers.stellar.org/docs/software-and-sdks/sdks/python/)

> **Dica:** O SDK Python √© ideal para automa√ß√µes, scripts, backends e prototipagem r√°pida de solu√ß√µes com Stellar.

### 8. Setup do Node Stellar (setup-node)

A pasta `setup-node` cont√©m tudo o que voc√™ precisa para rodar um ambiente local completo da Stellar, incluindo monitoramento com Prometheus e Grafana.

#### O que est√° inclu√≠do?

- **docker-compose.yaml:** Orquestra tr√™s servi√ßos:
  - **stellar:** Sobe um node Stellar local (com suporte a Soroban RPC).
  - **prometheus:** Coleta m√©tricas do node para monitoramento.
  - **grafana:** Exibe dashboards interativos para visualiza√ß√£o das m√©tricas.

- **prometheus.yml:** Configura o Prometheus para coletar m√©tricas do node Stellar na porta 6061.

- **stellar_dashboard.json:** Dashboard pronto para importar no Grafana, mostrando:
  - Total de transa√ß√µes processadas (`Total Tx`)
  - N√∫mero do ledger (bloco) mais recente (`Current Blocos (Ledger)`)

#### Como usar

1. **Suba o ambiente com Docker Compose:**
   ```bash
   cd aula02/setup-node
   docker-compose up
   ```
2. **Acesse os servi√ßos:**
   - Node Stellar: http://localhost:8000
   - Prometheus: http://localhost:9090
   - Grafana: http://localhost:3000 (usu√°rio/senha padr√£o: admin/admin)

3. **Importe o dashboard no Grafana:**
   - Use o arquivo `stellar_dashboard.json` para visualizar as principais m√©tricas do node.

#### Benef√≠cios

- Permite testar, desenvolver e monitorar aplica√ß√µes Stellar localmente, sem custos.
- O monitoramento facilita o entendimento do funcionamento do node e a detec√ß√£o de problemas.

> **Dica:** Esse setup √© ideal para quem est√° aprendendo, desenvolvendo integra√ß√µes ou testando contratos inteligentes com Soroban.

### 9. Passo a Passo: Levantando e Monitorando a Blockchain Stellar Local

Agora vamos colocar em pr√°tica tudo o que aprendemos, levantando um ambiente completo de desenvolvimento Stellar local.

#### Passo 1: Preparar o ambiente

Certifique-se de ter o Docker e Docker Compose instalados:

```bash
# Verificar se o Docker est√° rodando
docker --version
docker-compose --version
```

#### Passo 2: Levantar o node Stellar local

```bash
# Navegar para a pasta do setup
cd aula02/setup-node

# Subir todos os servi√ßos
docker-compose up -d

# Verificar se os containers est√£o rodando
docker-compose ps
```

#### Passo 3: Acessar os servi√ßos

- **Node Stellar:** http://localhost:8000
- **Prometheus:** http://localhost:9090
- **Grafana:** http://localhost:3000 (admin/admin)

#### Passo 4: Configurar o Grafana

1. Acesse http://localhost:3000
2. Fa√ßa login com admin/admin
3. Importe o dashboard usando o arquivo `stellar_dashboard.json`
4. Configure o datasource do Prometheus se necess√°rio

#### Passo 5: Executar os exemplos do SDK

Agora que o node est√° rodando, voc√™ pode executar os exemplos pr√°ticos disponibilizados na pasta `aula02/sdk`:

```bash
# Navegar para a pasta do SDK
cd aula02/sdk

# Instalar depend√™ncias com poetry
poetry install

# Executar exemplo de pagamento
cd payment
poetry run python main.py

# Executar exemplo de cria√ß√£o de token
cd ../token
poetry run python main.py
```

Ou se preferir usar pip diretamente:

```bash
pip install stellar-sdk
python main.py
```

#### O que voc√™ ver√°

- **No Grafana:** M√©tricas em tempo real do node (transa√ß√µes, ledgers, etc.)
- **Nos scripts Python:** Cria√ß√£o de contas, pagamentos, emiss√£o de tokens
- **No console:** Logs das opera√ß√µes sendo executadas na blockchain local

#### Benef√≠cios deste setup

- **Desenvolvimento seguro:** Teste sem custos reais
- **Monitoramento completo:** Visualize o que acontece na blockchain
- **Aprendizado pr√°tico:** Execute opera√ß√µes reais em ambiente controlado
- **Prepara√ß√£o para produ√ß√£o:** Entenda como funciona antes de usar a rede principal

> **Dica:** Mantenha este ambiente rodando durante todo o desenvolvimento. Ele ser√° √∫til para testar contratos Soroban, integra√ß√µes e novas funcionalidades.

## Aula 3: Introdu√ß√£o ao Rust e Smart Contracts Soroban

### 1. Filosofia do Rust

O Rust √© uma linguagem de programa√ß√£o que prioriza **seguran√ßa, performance e concorr√™ncia** sem comprometer a velocidade de execu√ß√£o. Suas principais caracter√≠sticas incluem:

- **Seguran√ßa de Mem√≥ria:** Sistema de propriedade que previne erros comuns como vazamentos de mem√≥ria e refer√™ncias inv√°lidas
- **Performance:** Velocidade compar√°vel a C/C++ com garantias de seguran√ßa
- **Concorr√™ncia:** Modelo seguro de concorr√™ncia que previne condi√ß√µes de corrida

### 2. Ecossistema Rust

O ecossistema Rust oferece ferramentas robustas para desenvolvimento:

- **Rustup:** Gerenciador de vers√µes e instala√ß√£o do Rust
- **rustc:** Compilador oficial que garante c√≥digo seguro
- **Cargo:** Sistema de build e gerenciador de depend√™ncias
- **Crates:** Sistema de pacotes para reutiliza√ß√£o de c√≥digo

### 3. Compara√ß√£o com Outras Linguagens

| Aspecto | Rust | Python | JavaScript |
|---------|------|--------|------------|
| **Seguran√ßa** | Alta (sistema de propriedade) | M√©dia | Baixa |
| **Performance** | Muito alta | M√©dia | M√©dia |
| **Curva de Aprendizado** | √çngreme | Suave | Suave |
| **Ecossistema** | Crescente | Maduro | Muito maduro |

### 4. Smart Contracts com Soroban

Soroban √© a plataforma de smart contracts da Stellar, permitindo desenvolvimento em Rust:

- **Instala√ß√£o:** `cargo install --locked soroban-cli`
- **Target WASM:** `rustup target add wasm32-unknown-unknown`
- **Desenvolvimento:** Cria√ß√£o, build, teste e deploy de contratos
- **Intera√ß√£o:** Invoca√ß√£o de fun√ß√µes via CLI

### 5. Exemplo Pr√°tico: Hello World

A aula inclui um exemplo completo de smart contract "Hello World" que demonstra:
- Cria√ß√£o de projeto Soroban
- Estrutura b√°sica de um contrato
- Build e deploy
- Intera√ß√£o com o contrato

> **üìö Para mais detalhes, exemplos pr√°ticos e comandos espec√≠ficos, consulte o [README da Aula 3](./aula03/README.md)**

---

**Recursos Adicionais:**
- [The Rust Programming Language (The Book)](https://doc.rust-lang.org/book/)
- [Comprehensive Rust](https://google.github.io/comprehensive-rust/)
- [Rustlings](https://rustlings.cool)
- [Rust by Examples](https://doc.rust-lang.org/rust-by-example/)

### 6. Rustlings: Exerc√≠cios Pr√°ticos

O **Rustlings** √© uma ferramenta essencial para aprender Rust atrav√©s da pr√°tica. Ele oferece uma s√©rie de exerc√≠cios que cobrem desde conceitos b√°sicos at√© t√≥picos avan√ßados da linguagem.

#### O que √© o Rustlings?

- **Exerc√≠cios Progressivos:** 100+ exerc√≠cios organizados por dificuldade
- **Feedback Imediato:** Verifica√ß√£o autom√°tica do c√≥digo com dicas espec√≠ficas
- **Aprendizado Pr√°tico:** Aprenda corrigindo erros e completando c√≥digo incompleto
- **Cobertura Completa:** Desde sintaxe b√°sica at√© conceitos avan√ßados como ownership, borrowing e lifetimes

#### Como come√ßar

1. **Instala√ß√£o:**
   ```bash
   git clone https://github.com/rust-lang/rustlings
   cd rustlings
   cargo install --force --path .
   ```

2. **Verificar exerc√≠cios dispon√≠veis:**
   ```bash
   rustlings list
   ```

3. **Iniciar os exerc√≠cios:**
   ```bash
   rustlings watch
   ```

#### Como resolver os exerc√≠cios

- **Leia o coment√°rio:** Cada exerc√≠cio tem instru√ß√µes claras no c√≥digo
- **Analise o erro:** O compilador Rust fornece mensagens detalhadas
- **Teste suas mudan√ßas:** Use `rustlings verify` para verificar se est√° correto
- **Continue progredindo:** Resolva um exerc√≠cio por vez

#### Exemplos de t√≥picos cobertos

- **Vari√°veis e tipos:** `variables`, `functions`, `if`, `move_semantics`
- **Ownership e Borrowing:** `ownership`, `borrowing`, `lifetimes`
- **Structs e Enums:** `structs`, `enums`, `error_handling`
- **Collections:** `vecs`, `strings`, `hashmaps`
- **Advanced Topics:** `traits`, `generics`, `iterators`

#### Dicas para sucesso

- **N√£o desista:** A curva de aprendizado √© √≠ngreme, mas vale a pena
- **Leia as mensagens de erro:** Elas s√£o muito informativas
- **Use a documenta√ß√£o:** `rustlings hint <exercise_name>` para dicas
- **Pratique regularmente:** Dedique tempo di√°rio aos exerc√≠cios

> **üí° Dica:** Rustlings √© considerado o melhor caminho para aprender Rust de forma pr√°tica. Complete todos os exerc√≠cios antes de avan√ßar para projetos mais complexos.

## Aula 4: Smart Contracts Soroban Avan√ßados

### 1. Flipando bits (Flipper)

O contrato **Flipper** √© um exemplo fundamental que demonstra como gerenciar estado booleano em smart contracts Soroban. Ele implementa um "flip-flop" que alterna entre `true` e `false`.

#### Conceitos Aprendidos:
- **Estado Persistente:** Armazenamento de dados na blockchain
- **Opera√ß√µes Booleanas:** Manipula√ß√£o de valores true/false
- **Storage Instance:** Uso do sistema de armazenamento do Soroban
- **Symbols:** Identificadores para chaves de armazenamento

#### Estrutura do Contrato:
```rust
#[contract]
pub struct Flipper;

#[contractimpl]
impl Flipper {
    pub fn flip(env: Env) {
        let mut state: bool = env.storage().instance().get(&STATE).unwrap_or(false);
        state = !state;
        env.storage().instance().set(&STATE, &state);
    }

    pub fn get_state(env: Env) -> bool {
        env.storage().instance().get(&STATE).unwrap_or(false)
    }
}
```

#### Funcionalidades:
- **`flip()`:** Inverte o estado atual (true ‚Üí false, false ‚Üí true)
- **`get_state()`:** Retorna o estado atual do contrato

### 2. Entendendo sobre armazenamento (Counter)

O contrato **Counter** demonstra conceitos avan√ßados de armazenamento e gerenciamento de ciclo de vida em smart contracts.

#### Conceitos Aprendidos:
- **Contadores:** Incremento de valores num√©ricos
- **TTL (Time To Live):** Gerenciamento de expira√ß√£o de dados
- **Logging:** Registro de eventos durante execu√ß√£o
- **Armazenamento Persistente:** Manuten√ß√£o de estado entre transa√ß√µes

#### Estrutura do Contrato:
```rust
#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    pub fn increment(env: Env) {
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0);
        log!(&env, "count: {}", count);
        count += 1;
        env.storage().instance().set(&COUNTER, &count);
        env.storage().instance().extend_ttl(50, 100);
    }

    pub fn get_counter(env: Env) -> u32 {
        env.storage().instance().get(&COUNTER).unwrap_or(0)
    }
}
```

#### Funcionalidades:
- **`increment()`:** Incrementa o contador e estende o TTL
- **`get_counter()`:** Retorna o valor atual do contador
- **TTL Management:** Extens√£o autom√°tica do tempo de vida dos dados

### 3. Avan√ßando em l√≥gica (Task Manager)

O contrato **Task Manager** √© um exemplo completo de aplica√ß√£o CRUD (Create, Read, Update, Delete) que demonstra estruturas de dados complexas e gerenciamento de estado avan√ßado.

#### Conceitos Aprendidos:
- **Estruturas de Dados:** Defini√ß√£o de tipos customizados
- **Maps e Collections:** Armazenamento de dados estruturados
- **Error Handling:** Tratamento de erros com enums
- **CRUD Operations:** Opera√ß√µes completas de banco de dados
- **Traits:** Defini√ß√£o de interfaces para contratos

#### Estrutura do Contrato:
```rust
#[contracttype]
pub struct Task {
    pub id: u32,
    pub name: Symbol,
    pub done: bool,
}

#[contracterror]
pub enum Error {
    ReadyTwice = 1,
    NotFound = 2,
}

pub trait CRUD {
    fn add_task(env: Env, name: Symbol) -> u32;
    fn get_task(env: Env, id: u32) -> Option<Task>;
    fn get_all_tasks(env: Env) -> Vec<Task>;
    fn complete_task(env: Env, id: u32) -> Result<bool, Error>;
    fn delete_task(env: Env, id: u32) -> Result<bool, Error>;
}
```

#### Funcionalidades:
- **`add_task()`:** Cria uma nova tarefa
- **`get_task()`:** Recupera uma tarefa espec√≠fica
- **`get_all_tasks()`:** Lista todas as tarefas
- **`complete_task()`:** Marca uma tarefa como conclu√≠da
- **`delete_task()`:** Remove uma tarefa

### 4. Configura√ß√£o e Deploy

#### Setup do Ambiente:
```bash
# Configurar rede local
soroban config network add local \
    --rpc-url "http://localhost:8000/soroban/rpc" \
    --network-passphrase "Standalone Network ; February 2017"

# Gerar chave de teste
soroban keys generate --global bob --network local
```

#### Build e Deploy:
```bash
# Compilar contratos
soroban contract build

# Deploy do contrato
soroban contract deploy \
  --wasm target/wasm32-unknown-unknown/release/<CONTRACT_NAME>.wasm \
  --source bob \
  --network local
```

#### Intera√ß√£o com Contratos:
```bash
# Exemplo: Interagir com Task Manager
soroban contract invoke \
  --id <CONTRACT_ID> \
  --source bob \
  --network local \
  -- \
  add_task \
  --name "Limpar_o_carro"
```

### 5. Conceitos Avan√ßados Aprendidos

#### Storage Patterns:
- **Instance Storage:** Para dados que vivem com o contrato
- **Persistent Storage:** Para dados que sobrevivem ao contrato
- **TTL Management:** Controle de expira√ß√£o de dados

#### Error Handling:
- **Custom Errors:** Defini√ß√£o de tipos de erro espec√≠ficos
- **Result Types:** Tratamento seguro de opera√ß√µes que podem falhar
- **Option Types:** Para valores que podem n√£o existir

#### Data Structures:
- **Structs:** Defini√ß√£o de tipos customizados
- **Enums:** Para tipos com variantes
- **Maps:** Para armazenamento chave-valor
- **Vec:** Para listas din√¢micas

> **üìö Para exemplos pr√°ticos, comandos espec√≠ficos e resultados dos testes, consulte o [README da Aula 4](./aula04/README.md)**

### ‚úÖ **Status da Aula 4: COMPLETA E FUNCIONAL**

- ‚úÖ **3 contratos implementados e testados:** Flipper, Increment, Task Manager
- ‚úÖ **Ambiente configurado:** Node local, friendbot, CLI atualizada
- ‚úÖ **Documenta√ß√£o atualizada:** Comandos corretos da vers√£o mais recente
- ‚úÖ **Testes realizados:** Todas as funcionalidades funcionando perfeitamente

## Aula 5: No√ß√µes Avan√ßadas de Soroban

### üéØ **Objetivo da Aula 5**

Esta aula foca em conceitos avan√ßados de Soroban, incluindo implementa√ß√£o de tokens completos, padr√µes ERC-20, aliases para produtividade e opera√ß√µes complexas de smart contracts.

### üìö **Conceitos Avan√ßados:**

#### **1. Padr√£o ERC-20 Completo**
- **Mint:** Cria√ß√£o de tokens
- **Transfer:** Transfer√™ncia direta
- **Approve/TransferFrom:** Padr√£o de aprova√ß√£o
- **Balance:** Consultas de saldo
- **Admin:** Controle administrativo

#### **2. Produtividade Avan√ßada**
- **Aliases:** Configura√ß√£o de atalhos para comandos
- **Vari√°veis de ambiente:** Simplifica√ß√£o de comandos
- **Workflow otimizado:** Processos eficientes

#### **3. Opera√ß√µes de Token**
- **Inicializa√ß√£o:** Configura√ß√£o inicial do contrato
- **Mint:** Cria√ß√£o de novos tokens
- **Transfer:** Transfer√™ncia entre contas
- **Approve:** Autoriza√ß√£o de gastos
- **TransferFrom:** Transfer√™ncia autorizada

#### **4. Tipos de Storage em Soroban**
Soroban oferece tr√™s tipos principais de storage, cada um com caracter√≠sticas espec√≠ficas de tempo de vida e uso:

##### **Instance Storage**
- **Tempo de Vida:** Vive apenas durante a execu√ß√£o da transa√ß√£o
- **Escopo:** Limitado ao contrato atual
- **Uso:** Dados tempor√°rios, vari√°veis de estado durante execu√ß√£o
- **Exemplo:** Contadores tempor√°rios, flags de estado durante opera√ß√£o
- **Custo:** Mais barato, mas dados s√£o perdidos ap√≥s a transa√ß√£o

##### **Persistent Storage**
- **Tempo de Vida:** Sobrevive entre transa√ß√µes e at√© mesmo ap√≥s upgrades do contrato
- **Escopo:** Associado ao contrato espec√≠fico
- **Uso:** Dados que precisam persistir (saldos, configura√ß√µes, estado global)
- **Exemplo:** Balances de tokens, configura√ß√µes administrativas, dados de usu√°rios
- **Custo:** Mais caro, mas dados s√£o mantidos permanentemente
- **TTL:** Pode ser estendido usando `extend_ttl()`

##### **Temporary Storage**
- **Tempo de Vida:** Muito curto, apenas durante a execu√ß√£o da fun√ß√£o
- **Escopo:** Limitado √† fun√ß√£o atual
- **Uso:** Dados intermedi√°rios, c√°lculos tempor√°rios
- **Exemplo:** Vari√°veis de loop, resultados intermedi√°rios de c√°lculos
- **Custo:** Mais barato que persistent, mas dados s√£o perdidos imediatamente

##### **Gerenciamento de TTL (Time To Live)**
- **TTL Threshold:** Define quando o TTL deve ser estendido
- **TTL Extend:** Permite estender o tempo de vida dos dados persistentes
- **Estrat√©gia:** Estender TTL antes que os dados expirem para evitar perda
- **Exemplo:** `env.storage().instance().extend_ttl(50, 100)` - estende TTL para 100 ledgers

##### **Implementa√ß√£o Pr√°tica de TTL no Token Contract**
```rust
// Constantes de TTL definidas em storage_types.rs
pub(crate) const DAY_IN_LEDGERS: u32 = 17280;
pub(crate) const INSTANCE_BUMP_AMOUNT: u32 = 7 * DAY_IN_LEDGERS;        // 7 dias
pub(crate) const INSTANCE_LIFETIME_THRESHOLD: u32 = INSTANCE_BUMP_AMOUNT - DAY_IN_LEDGERS;

pub(crate) const BALANCE_BUMP_AMOUNT: u32 = 30 * DAY_IN_LEDGERS;        // 30 dias
pub(crate) const BALANCE_LIFETIME_THRESHOLD: u32 = BALANCE_BUMP_AMOUNT - DAY_IN_LEDGERS;

// Uso em cada fun√ß√£o do contrato
e.storage()
    .instance()
    .extend_ttl(INSTANCE_LIFETIME_THRESHOLD, INSTANCE_BUMP_AMOUNT);
```

##### **Tipos de Extens√£o de TTL**
- **Instance Storage:** `e.storage().instance().extend_ttl(threshold, bump_amount)`
- **Persistent Storage:** `e.storage().persistent().extend_ttl(&key, threshold, bump_amount)`
- **Temporary Storage:** `e.storage().temporary().extend_ttl(&key, threshold, bump_amount)`

##### **Arquivamento de Contratos**
- **O que √©:** Processo de desativar um contrato sem deletar seus dados
- **Storage Persistente:** Dados persistentes continuam existindo mesmo ap√≥s arquivamento
- **Storage Instance:** Dados de inst√¢ncia s√£o perdidos quando o contrato √© arquivado
- **Recupera√ß√£o:** Contratos arquivados podem ser "desarquivados" se necess√°rio
- **Custos:** Contratos arquivados ainda geram custos de storage para dados persistentes
- **Comando:** `soroban contract archive <CONTRACT_ID>` - arquiva um contrato

### üèóÔ∏è **Contrato Token Implementado:**

- **Estrutura modular:** Separa√ß√£o clara de responsabilidades
- **M√≥dulos:** admin, allowance, balance, contract, metadata, storage_types
- **Interface:** TokenClient para intera√ß√£o
- **Padr√£o completo:** Implementa√ß√£o ERC-20 completa

### ‚ö†Ô∏è **Limita√ß√µes e Melhorias Identificadas:**

#### **1. Problemas com Initialize**
- **Seguran√ßa:** Fun√ß√£o `initialize` n√£o √© muito segura para produ√ß√£o
- **Experi√™ncia:** N√£o √© a melhor abordagem para deploy em produ√ß√£o
- **Recomenda√ß√£o:** Usar SDKs (Python/JavaScript) para empacotar deploy + inicializa√ß√£o
- **Vantagem SDK:** Tudo em uma √∫nica transa√ß√£o, mais seguro e eficiente

#### **2. Impacto do EVM (Ethereum Virtual Machine)**
- **Trait Interface:** Implementa padr√£o ERC-20 similar ao Ethereum
- **Compatibilidade:** Mesmo sendo diferente da documenta√ß√£o ETH, √© muito parecido
- **L√≥gica dos M√©todos:** Segue padr√£o ERC-20 mas com l√≥gica espec√≠fica do Soroban
- **Diferen√ßas:** Adapta√ß√µes para o ambiente Stellar/Soroban

#### **3. Recomenda√ß√µes para Produ√ß√£o**
- **SDK Python/JavaScript:** Para deploy e inicializa√ß√£o empacotados
- **Testes com SDK:** Melhor experi√™ncia de desenvolvimento
- **Seguran√ßa:** Evitar initialize separado em produ√ß√£o
- **Padr√µes:** Seguir padr√µes ERC-20 mas adaptados ao Soroban

#### **4. Diferen√ßas ERC-20 Ethereum vs Soroban**
- **Environment:** EVM vs Soroban Environment
- **Gas:** Ethereum gas vs Stellar fees
- **Storage:** Ethereum storage vs Soroban storage types
- **TTL:** Ethereum n√£o tem TTL vs Soroban com TTL management
- **Consensus:** PoW vs Stellar Consensus Protocol (SCP)
- **Accounts:** Ethereum addresses vs Stellar addresses
- **Events:** Ethereum events vs Soroban events
- **Authorization:** Ethereum msg.sender vs Soroban require_auth()

### üíæ **Aplica√ß√£o dos Tipos de Storage no Token:**

#### **Persistent Storage (Principal)**
- **Balances:** Saldos dos usu√°rios s√£o armazenados persistentemente
- **Allowances:** Autoriza√ß√µes de gasto entre usu√°rios
- **Admin:** Endere√ßo do administrador do contrato
- **Metadata:** Nome, s√≠mbolo e decimais do token

#### **Instance Storage (Auxiliar)**
- **Contadores tempor√°rios:** Durante opera√ß√µes de mint/burn
- **Flags de estado:** Durante valida√ß√µes de opera√ß√µes
- **Dados de transa√ß√£o:** Informa√ß√µes tempor√°rias durante execu√ß√£o

#### **Temporary Storage (Interno)**
- **C√°lculos intermedi√°rios:** Durante opera√ß√µes matem√°ticas
- **Vari√°veis de loop:** Durante itera√ß√µes em opera√ß√µes em lote
- **Resultados tempor√°rios:** Durante valida√ß√µes e verifica√ß√µes

### üìã **Funcionalidades:**

- ‚úÖ **Deploy e Inicializa√ß√£o** de contratos token
- ‚úÖ **Mint de tokens** para diferentes contas
- ‚úÖ **Transfer√™ncias diretas** entre contas
- ‚úÖ **Sistema de aprova√ß√£o** (Approve/TransferFrom)
- ‚úÖ **Consultas de saldo** e informa√ß√µes administrativas
- ‚úÖ **Aliases configurados** para produtividade

### üöÄ **Status:**

- ‚úÖ **Estrutura criada** e organizada
- ‚úÖ **Comandos atualizados** para vers√£o mais recente
- ‚úÖ **Documenta√ß√£o completa** com exemplos pr√°ticos
- ‚úÖ **Funcionalidade b√°sica testada** com sucesso

### ‚úÖ **Status da Aula 5: TODAS AS FUNCIONALIDADES TESTADAS E FUNCIONANDO!**

#### üöÄ **Testes Locais - CONCLU√çDOS**
**Contrato Deployado:** `CAPGL5BDXOPAND4PWDVY2KTAGJ6FUWPRNVKSVE2OLXPYYVQ7ZXRX2AAC`

**Funcionalidades Testadas Localmente:**
- ‚úÖ **Deploy e Inicializa√ß√£o** do contrato token
- ‚úÖ **Mint de tokens** (100 DREX para alice)
- ‚úÖ **Transfer√™ncia direta** (50 DREX de alice para bob)
- ‚úÖ **Burn de tokens** (10 DREX de bob)
- ‚úÖ **Consulta de metadados** (nome: RealDigital, s√≠mbolo: DREX, decimais: 2)
- ‚úÖ **Consulta de saldos** e emiss√£o de eventos

**Saldo Final Local:**
- Alice: 50 DREX tokens
- Bob: 40 DREX tokens
- Total em circula√ß√£o: 90 DREX tokens

#### üåê **Testes na Testnet - CONCLU√çDOS**
**Contrato Deployado:** `CBXWMW3YLXYL7DKOCCMKQ7M7CEGMWXB5TQB2BSF3BNVVQR73DPXDYNPW`

**Funcionalidades Testadas na Testnet:**
- ‚úÖ **Deploy e Inicializa√ß√£o** do contrato token
- ‚úÖ **Mint de tokens** (1000 DREX para alice, 500 DREX para bob)
- ‚úÖ **Transfer√™ncia direta** (200 DREX de alice para bob)
- ‚úÖ **Approve/TransferFrom** (Alice aprovou bob para 300 DREX, bob transferiu 150 DREX)
- ‚úÖ **Burn de tokens** (50 DREX de bob, 25 DREX de alice)
- ‚úÖ **BurnFrom** (Bob queimou 25 DREX de alice usando aprova√ß√£o)
- ‚úÖ **SetAdmin** (Admin transferido de bob para alice)
- ‚úÖ **Consulta de metadados** e saldos
- ‚úÖ **Emiss√£o de eventos** para todas as opera√ß√µes

**Saldo Final na Testnet:**
- Bob: 800 DREX
- Alice: 625 DREX
- Total em circula√ß√£o: 1425 DREX

#### üìÅ **Arquivos Criados para Testnet:**
- **Scripts:** `setup_testnet.sh`, `testnet_test.sh`, `testnet_commands.sh`
- **Documenta√ß√£o:** `TESTNET_GUIDE.md`, `README_TESTNET.md`, `INDEX_TESTNET.md`, `TESTNET_RESULTS.md`

#### üéØ **Status Final: CONTRATO TOKEN 100% FUNCIONAL!**
O contrato est√° **pronto para uso em produ√ß√£o** na mainnet da Stellar!

> **üìö Para comandos detalhados e resultados dos testes, consulte o [README da Aula 5](./aula05/README.md)**

### üöÄ **Melhorias com SDKs:**

#### **1. Deploy com Python SDK**
```python
from stellar_sdk import Server, Keypair, TransactionBuilder, Network
from stellar_sdk.operation.invoke_host_function import InvokeHostFunction
from stellar_sdk.operation.extend_footprint_ttl import ExtendFootprintTTL

# Deploy + Initialize em uma √∫nica transa√ß√£o
def deploy_token_with_initialize():
    # 1. Deploy do contrato
    # 2. Initialize com par√¢metros
    # 3. Tudo em uma transa√ß√£o at√¥mica
    pass
```

#### **2. Deploy com JavaScript SDK**
```javascript
const { SorobanRpc, TransactionBuilder, Networks } = require('stellar-sdk');

// Deploy + Initialize empacotado
async function deployTokenWithInitialize() {
    // 1. Deploy do contrato WASM
    // 2. Initialize com metadata
    // 3. Transa√ß√£o √∫nica e segura
}
```

#### **3. Vantagens dos SDKs**
- **Atomicidade:** Deploy + Initialize em uma transa√ß√£o
- **Seguran√ßa:** Evita race conditions e ataques
- **Experi√™ncia:** Melhor DX (Developer Experience)
- **Testes:** Mais f√°cil de testar e debugar
- **Produ√ß√£o:** Pronto para ambiente real

#### **4. Testes com SDKs**
```python
# Exemplo de teste com Python SDK
def test_token_operations():
    # Deploy com initialize
    token_contract = deploy_token_with_initialize()
    
    # Testar opera√ß√µes
    token_contract.mint(to=alice, amount=100)
    token_contract.transfer(from=alice, to=bob, amount=50)
    
    # Verificar resultados
    assert token_contract.balance(alice) == 50
    assert token_contract.balance(bob) == 50
```

```javascript
// Exemplo de teste com JavaScript SDK
describe('Token Contract', () => {
    it('should deploy and initialize correctly', async () => {
        const token = await deployTokenWithInitialize();
        expect(token.name()).toBe('RealDigital');
        expect(token.symbol()).toBe('DREX');
    });
    
    it('should handle mint and transfer', async () => {
        await token.mint(alice, 100);
        await token.transfer(alice, bob, 50);
        
        expect(await token.balance(alice)).toBe(50);
        expect(await token.balance(bob)).toBe(50);
    });
});
```

### üîÑ **Arquitetura Completa: Rust + SDKs + Frontend**

#### **1. Como Funciona a Integra√ß√£o:**

##### **Rust (Smart Contract)**
- **O que √©:** Linguagem para escrever o smart contract
- **Onde roda:** Compilado para WASM e executado na blockchain Stellar
- **Fun√ß√£o:** Define a l√≥gica do contrato (mint, transfer, approve, etc.)

```rust
// aula05/contracts/token/src/lib.rs
// Este √© o smart contract em Rust
pub struct Token;

impl Token {
    pub fn mint(e: Env, to: Address, amount: i128) {
        // L√≥gica do mint
    }
    
    pub fn transfer(e: Env, from: Address, to: Address, amount: i128) {
        // L√≥gica do transfer
    }
}
```

##### **Python/JavaScript (SDK - Backend)**
- **O que √©:** C√≥digo para interagir com a blockchain Stellar
- **Onde roda:** No seu computador/servidor (backend)
- **Fun√ß√£o:** Deploy, inicializa√ß√£o e intera√ß√£o com o contrato

```python
# deploy_token.py (Backend)
from stellar_sdk import Server, Keypair, TransactionBuilder

def deploy_and_initialize_token():
    # 1. Compila o contrato Rust para WASM
    # 2. Faz deploy do WASM na blockchain
    # 3. Chama initialize() com os par√¢metros
    # 4. Tudo em uma √∫nica transa√ß√£o
    pass
```

#### **2. Fluxo Completo de Desenvolvimento:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend      ‚îÇ    ‚îÇ   Backend       ‚îÇ    ‚îÇ   Blockchain    ‚îÇ
‚îÇ   (React/Vue)   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (Python/JS)   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (Stellar)     ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ - Interface     ‚îÇ    ‚îÇ - Deploy        ‚îÇ    ‚îÇ - Smart         ‚îÇ
‚îÇ - Intera√ß√£o     ‚îÇ    ‚îÇ - Initialize    ‚îÇ    ‚îÇ   Contract      ‚îÇ
‚îÇ - Visualiza√ß√£o  ‚îÇ    ‚îÇ - API Calls     ‚îÇ    ‚îÇ   (Rust/WASM)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### **3. Exemplo Pr√°tico de Implementa√ß√£o:**

##### **Passo 1: Desenvolver o Contrato (Rust)**
```bash
# Voc√™ escreve o contrato em Rust
cd aula05/contracts/token
cargo build --target wasm32-unknown-unknown --release
# Gera: target/wasm32-unknown-unknown/release/token.wasm
```

##### **Passo 2: Deploy com SDK (Python/JavaScript)**
```python
# deploy_token.py
import subprocess
from stellar_sdk import SorobanRpc, TransactionBuilder

# 1. Compilar o contrato Rust
subprocess.run(["cargo", "build", "--target", "wasm32-unknown-unknown", "--release"])

# 2. Ler o arquivo WASM
with open("target/wasm32-unknown-unknown/release/token.wasm", "rb") as f:
    wasm_bytes = f.read()

# 3. Deploy + Initialize em uma transa√ß√£o
def deploy_token():
    # Deploy do WASM
    deploy_op = InvokeHostFunction(
        host_function=HostFunction.deploy_contract(wasm_bytes)
    )
    
    # Initialize com par√¢metros
    init_op = InvokeHostFunction(
        host_function=HostFunction.invoke_contract(
            contract_id=deployed_contract_id,
            function_name="initialize",
            args=[admin, decimal, name, symbol]
        )
    )
    
    # Tudo em uma transa√ß√£o
    transaction = TransactionBuilder(...)
    transaction.add_operation(deploy_op)
    transaction.add_operation(init_op)
    transaction.submit()
```

#### **4. Arquitetura de Produ√ß√£o:**

##### **Backend (Python) - Deploy Service:**
```python
# services/token_service.py
class TokenService:
    def deploy_token(self, name, symbol, decimal, admin):
        # 1. Compila o contrato Rust
        self.compile_rust_contract()
        
        # 2. Deploy + Initialize
        contract_id = self.deploy_and_initialize(name, symbol, decimal, admin)
        
        # 3. Retorna o contract_id para o frontend
        return contract_id
    
    def mint_tokens(self, contract_id, to, amount):
        # Chama a fun√ß√£o mint do contrato
        return self.invoke_contract(contract_id, "mint", [to, amount])
```

##### **Frontend (JavaScript) - Interface:**
```javascript
// frontend/src/components/TokenDeploy.js
class TokenDeploy {
    async deployToken(name, symbol, decimal) {
        // Chama o backend para fazer deploy
        const response = await fetch('/api/deploy-token', {
            method: 'POST',
            body: JSON.stringify({ name, symbol, decimal })
        });
        
        const { contract_id } = await response.json();
        
        // Salva o contract_id para usar depois
        this.contractId = contract_id;
    }
    
    async mintTokens(to, amount) {
        // Chama o backend para mint
        await fetch('/api/mint-tokens', {
            method: 'POST',
            body: JSON.stringify({
                contract_id: this.contractId,
                to, amount
            })
        });
    }
}
```

#### **5. Vantagens desta Abordagem:**

##### **Seguran√ßa:**
- Deploy + Initialize em uma transa√ß√£o at√¥mica
- Evita race conditions
- Mais seguro que CLI manual

##### **Produtividade:**
- Automatiza o processo
- Menos erros manuais
- Melhor DX (Developer Experience)

##### **Flexibilidade:**
- Pode integrar com qualquer frontend
- APIs RESTful para intera√ß√£o
- F√°cil de testar e debugar

#### **6. Resumo da Arquitetura:**
- **Rust:** Smart contract (l√≥gica da blockchain)
- **Python/JavaScript:** Backend (deploy e intera√ß√£o)
- **Frontend:** Interface do usu√°rio
- **Stellar:** Blockchain (executa o contrato)

**Analogia:** √â como se voc√™ tivesse:
- **Rust** = O "motor" (smart contract)
- **Python/JS** = O "controlador" (deploy e API)
- **Frontend** = O "painel" (interface do usu√°rio)

#### **7. Quando Usar Cada Abordagem:**

##### **CLI (Soroban CLI) - Para Aprendizado/Testes:**
- ‚úÖ **Quando usar:** Desenvolvimento inicial, testes, aprendizado
- ‚úÖ **Vantagens:** Simples, direto, bom para entender conceitos
- ‚ùå **Limita√ß√µes:** Manual, propenso a erros, n√£o √© seguro para produ√ß√£o

##### **SDKs (Python/JavaScript) - Para Produ√ß√£o:**
- ‚úÖ **Quando usar:** Aplica√ß√µes reais, produ√ß√£o, integra√ß√£o com frontend
- ‚úÖ **Vantagens:** Automatizado, seguro, escal√°vel, melhor DX
- ‚úÖ **Ideal para:** Deploy services, APIs, aplica√ß√µes web/mobile

##### **Exemplo de Decis√£o:**
```bash
# Desenvolvimento/Aprendizado
soroban contract deploy --wasm token.wasm
soroban contract invoke --id <ID> -- initialize --admin <ADMIN>

# Produ√ß√£o
python deploy_service.py  # Deploy + Initialize autom√°tico
curl /api/deploy-token    # API para frontend
```

### üîß **Comandos de Arquivamento:**

#### **Arquivar Contrato**
```bash
soroban contract archive <CONTRACT_ID> --rpc-url <RPC_URL> --network-passphrase <PASSPHRASE>
```

#### **Verificar Status do Contrato**
```bash
soroban contract show <CONTRACT_ID> --rpc-url <RPC_URL> --network-passphrase <PASSPHRASE>
```

#### **Desarquivar Contrato (se suportado)**
```bash
soroban contract restore <CONTRACT_ID> --rpc-url <RPC_URL> --network-passphrase <PASSPHRASE>
```

#### **Exemplo Pr√°tico**
```bash
# Arquivar o contrato token da Aula 5
soroban contract archive CAPGL5BDXOPAND4PWDVY2KTAGJ6FUWPRNVKSVE2OLXPYYVQ7ZXRX2AAC \
  --rpc-url "http://localhost:8000/soroban/rpc" \
  --network-passphrase "Standalone Network ; February 2017"
```

### ‚è∞ **Comandos de Verifica√ß√£o de TTL:**

#### **Verificar TTL do Contrato**
```bash
soroban contract show <CONTRACT_ID> --rpc-url <RPC_URL> --network-passphrase <PASSPHRASE>
```

#### **Verificar TTL de Dados Espec√≠ficos**
```bash
# Para verificar TTL de balances (via fun√ß√£o do contrato)
soroban contract invoke --id <CONTRACT_ID> -- balance --id <ADDRESS>
```

#### **Monitoramento de TTL**
```bash
# Verificar ledger atual
soroban config network show

# Calcular quando TTL vai expirar
# TTL atual + bump_amount = expira√ß√£o
```

### üéØ **Estrat√©gias de Otimiza√ß√£o de Storage:**

#### **1. Escolha Inteligente do Tipo de Storage**
- **Use Persistent** apenas para dados que realmente precisam persistir
- **Use Instance** para dados tempor√°rios durante transa√ß√µes
- **Use Temporary** para c√°lculos intermedi√°rios

#### **2. Gerenciamento Eficiente de TTL**
- **Monitore TTL:** Acompanhe quando os dados v√£o expirar
- **Extenda Proativamente:** Estenda TTL antes da expira√ß√£o
- **Estrat√©gia de Threshold:** Configure thresholds apropriados para cada tipo de dado
- **Threshold Calculation:** `threshold = bump_amount - safety_margin` (ex: 1 dia de seguran√ßa)
- **Bump Amount:** Tempo total que o dado deve viver (ex: 7 dias para instance, 30 dias para persistent)
- **Automatic Extension:** Chame `extend_ttl()` em cada fun√ß√£o que acessa o storage

#### **3. Otimiza√ß√£o de Custos**
- **Persistent Storage:** Mais caro, use com modera√ß√£o
- **Instance Storage:** Custo m√©dio, ideal para dados tempor√°rios
- **Temporary Storage:** Mais barato, use para c√°lculos internos

#### **4. Padr√µes de Design**
- **Separa√ß√£o de Responsabilidades:** Diferentes tipos de storage para diferentes prop√≥sitos
- **Lazy Loading:** Carregue dados apenas quando necess√°rio
- **Batch Operations:** Agrupe opera√ß√µes para otimizar custos

#### **5. Estrat√©gias de Arquivamento**
- **Quando Arquivar:** Contratos que n√£o s√£o mais ativos mas precisam manter dados
- **Backup de Dados:** Fa√ßa backup de dados importantes antes do arquivamento
- **Planejamento de Recupera√ß√£o:** Mantenha documenta√ß√£o para desarquivamento futuro
- **Custos vs Benef√≠cios:** Avalie se vale a pena manter dados persistentes arquivados
- **Migra√ß√£o de Dados:** Considere migrar dados para novos contratos antes do arquivamento

#### **6. Impacto do Arquivamento no Storage**
- **Persistent Storage:** ‚úÖ **Mantido** - Dados sobrevivem ao arquivamento
- **Instance Storage:** ‚ùå **Perdido** - Dados s√£o limpos durante arquivamento
- **Temporary Storage:** ‚ùå **Perdido** - J√° n√£o existe ap√≥s execu√ß√£o da fun√ß√£o
- **TTL Management:** ‚ö†Ô∏è **Aten√ß√£o** - TTL continua contando mesmo em contratos arquivados

#### **7. Troubleshooting de TTL**
- **Erro "Data Expired":** Dados expiraram, precisa estender TTL antes de usar
- **Erro "TTL Too Low":** Threshold muito baixo, aumentar safety margin
- **Performance Issues:** Muitas extens√µes de TTL, otimizar frequ√™ncia
- **Custos Altos:** TTL muito longo, reduzir bump_amount
- **Preven√ß√£o:** Sempre chamar `extend_ttl()` em fun√ß√µes que acessam storage

### üìö **Li√ß√µes Aprendidas da Aula 5:**

#### **1. Limita√ß√µes do CLI**
- **Initialize Separado:** N√£o √© ideal para produ√ß√£o
- **Seguran√ßa:** Vulner√°vel a race conditions
- **Experi√™ncia:** Processo manual e propenso a erros

#### **2. Vantagens dos SDKs**
- **Deploy + Initialize:** Tudo em uma transa√ß√£o
- **Seguran√ßa:** Atomicidade garante consist√™ncia
- **Produtividade:** Melhor DX e menos erros

#### **3. Padr√µes ERC-20**
- **Compatibilidade:** Muito similar ao Ethereum
- **Adapta√ß√µes:** Necess√°rias para ambiente Soroban
- **L√≥gica:** Mesma funcionalidade, implementa√ß√£o diferente

#### **4. Pr√≥ximos Passos**
- **Aprender SDKs:** Python e JavaScript
- **Testes Avan√ßados:** Com frameworks de teste
- **Produ√ß√£o:** Implementar com SDKs
- **Padr√µes:** Seguir melhores pr√°ticas de seguran√ßa

## üîó **Links √öteis e Recursos**

### üìö **Documenta√ß√£o das Aulas:**
- [Aula 1-2: Fundamentos Stellar](./aula02/README.md)
- [Aula 3: Introdu√ß√£o ao Rust e Soroban](./aula03/README.md)
- [Aula 4: Smart Contracts Avan√ßados](./aula04/README.md)
- [Aula 5: Tokens ERC-20 e Testnet](./aula05/README.md)

### üöÄ **Recursos de Testnet:**
- **Contract Explorer:** https://soroban.stellar.org/
- **Transaction Explorer:** https://stellar.expert/explorer/testnet/contract/CBXWMW3YLXYL7DKOCCMKQ7M7CEGMWXB5TQB2BSF3BNVVQR73DPXDYNPW
- **Stellar Testnet:** https://laboratory.stellar.org/

### üìñ **Documenta√ß√£o Oficial:**
- [Stellar Documentation](https://developers.stellar.org/)
- [Soroban Documentation](https://soroban.stellar.org/docs)
- [Rust Programming Language](https://doc.rust-lang.org/book/)

### üõ†Ô∏è **Ferramentas:**
- [Stellar Laboratory](https://laboratory.stellar.org/)
- [Soroban CLI](https://soroban.stellar.org/docs/getting-started/setup)
- [Stellar Python SDK](https://stellar-sdk.readthedocs.io/)

---

## :memo: Licen√ßa

Esse projeto est√° sob a licen√ßa MIT. Veja o arquivo [LICENSE](https://github.com/git/git-scm.com/blob/master/MIT-LICENSE.txt) para mais detalhes.

---

Feito com üíú by <a href="https://www.linkedin.com/in/danielgorgonha/">Daniel R Gorgonha</a> :wave: